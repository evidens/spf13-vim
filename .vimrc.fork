" This file uses fold. Type zo -> open current fold; zR -> open all recursive
" Notes {
"
" F. Gabriel Gosselin custom vimrc <gabriel NOSPAM AT evidens DOT ca
" Inspired by
"   - http://spf13.com/post/perfect-vimrc-vim-config-file
"   - http://www.derekwyatt.org/vim/the-vimrc-file/my-vimrc-file/
"   - https://github.com/carlhuda/janus
"   - http://items.sjbach.com/319/configuring-vim-right
"   - http://stevelosh.com/blog/2010/09/coming-home-to-vim/
" }

" Environment {
    " Set visual bell -- no beeping!
    set vb

    " This is the timeout used while waiting for user input on a multi-keyed macro
    " or while just sitting and waiting for another key to be pressed measured
    " in milliseconds.
    "
    " i.e. for the ",d" command, there is a "timeoutlen" wait period between the
    "        "," key and the "d" key.  If the "d" key isn't pressed before the
    "        timeout expires, one of two things happens: The "," command is executed
    "        if there is one (which there isn't) or the command aborts.
    set timeoutlen=500
" }

" Display {
    " Command-line {
          " Make command line two-lines high
          set cmdheight=2
    " }

    " Status-line {
          " Set the status line the way I like it
          "set stl=%f\ %y%m\ Line:\ %l/%L[%p%%]\ Col:\ %c\ [0x%B]
    " }


    " Syntax colouring {
          " Syntax coloring lines that are too long just slows down the world
          set synmaxcol=2048
    "}

    " MacVim-specific options {
          if has('gui_macvim')
            " Fullscreen takes up entire screen
            set fuoptions=maxhorz,maxvert
            set colorcolumn=80

            " Allow meta (option) to be used in key bindings on map
            set macmeta

            " Toggle mac meta (allow special character typing OR meta binding)
            nnoremap <Leader>M :set macmeta!
          endif
    " }

    " Don't update the display while executing macros
    set lazyredraw
" }

" Editing {
    " How invisibles will be displayed
    set listchars=trail:·,tab:▸\ ,eol:¬,extends:#,nbsp:·

    " Set proper language
    set spelllang=en_gb

    " Set default font
    set gfn=Monaco\ for\ Powerline:h14

    " Makes indent align with shiftwidth
    set shiftround

    " Allow the cursor to go in to "invalid" places
    set virtualedit=all

    " Search options {
          " Use more standard regex
          nnoremap / /\v
          vnoremap / /\v

          set gdefault   " Use line global replace default
    " }

    " Don't use Ex mode, use Q for formatting
    noremap Q gq

    " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
    " so that you can undo CTRL-U after inserting a line break.
    inoremap <C-U> <C-G>u<C-U>


    " Only do this part when compiled with support for autocommands.
    if has("autocmd")

          " Put these in an autocmd group, so that we can delete them easily.
          augroup vimrcEx
                au!

                " For all text files set 'textwidth' to 78 characters.
                autocmd FileType text setlocal textwidth=78


                " When editing a file, always jump to the last known cursor position.
                " Don't do it when the position is invalid or when inside an event handler
                " (happens when dropping a file on gvim).
                " Also don't do it when the mark is in the first line, that is the default
                " position when opening a file.
                autocmd BufReadPost *
                    \ if line("'\"") > 1 && line("'\"") <= line("$") |
                    \   exe "normal! g`\"" |
                    \ endif
          augroup END
    else
          set autoindent  " always set autoindenting on
    endif " has("autocmd")

    " Convenient command to see the difference between the current buffer and the
    " file it was loaded from, thus the changes you made.
    " Only define it when not defined already.
    if !exists(":DiffOrig")
          command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
                    \ | wincmd p | diffthis
    endif
" }

" Mappings {
    " Easy escape
    inoremap <silent> jk <esc>

    " Toggle paste mode
    nnoremap <silent> <leader>p :set invpaste<CR>:set paste?<CR>

    " cd to the directory containing the file in the buffer
    nnoremap <silent> <leader>cd :lcd %:h<CR>
    nnoremap <silent> <leader>md :!mkdir -p %:p:h<CR>

    " Toggle show invisibles
    nnoremap <silent> <leader>s :set nolist!<CR>

    " Toggle relative lines
    nnoremap <silent> <leader>r :set relativenumber!<CR>
    " Complete tags
    inoremap <M-D-.> </<C-X><C-O>

    " CTags generate
    noremap <Leader>rt :!ctags --extra=+f -R *<CR><CR>
    nnoremap <F8> :!/usr/local/bin/ctags -R --python-kinds=-i *.py<CR>

    " TagExplorer
    nnoremap <silent> <leader>t :TlistToggle<CR>

    " Clean trailing spaces in a file
    nnoremap <Leader>W :%s/\s\+$//<cr>:let @/=''<CR>

    " Shortcut to set filetype to Django template (for new files)
    nnoremap <silent> <leader>dj :set filetype=htmldjango.html<CR>
    " Vimrc {
          " Let's make it easy to edit this file (mnemonic for the key sequence is
          " 'e'dit 'v'imrc)
          nnoremap <silent> <leader>ev :split $MYVIMRC<cr>

          " And to source this file as well (mnemonic for the key sequence is
          " 's'ource 'v'imrc)
          nnoremap <silent> <leader>sv :so $MYVIMRC<cr>
    " }
    " Window navigation {
          nnoremap <silent> <leader>h :wincmd h<CR>
          nnoremap <silent> <leader>j :wincmd j<CR>
          nnoremap <silent> <leader>k :wincmd k<CR>
          nnoremap <silent> <leader>l :wincmd l<CR>
    " }

    " Mappings inspired from http://learnvimscriptthehardway.stevelosh.com {
        " Move line up/down
        nnoremap - ddp
        nnoremap _ ddkP

        " Delete current line
        inoremap <c-d> <esc>ddi

        " Caplitalise current word
        inoremap <c-u> <esc>viwUea
        nnoremap <c-u> viwU


    " }
" }

" Plugin-specific settings {
    " NERDTree {
        function! NERDSafe(cmdname)
            if stridx(bufname("%"),"NERD_tree") >= 0
                :wincmd w
            endif
            exec a:cmdname
        endfunction
          nnoremap <leader>n :NERDTreeToggle<CR>
          nnoremap <leader>b :NERDTreeFromBookmark
          let NERDTreeShowBookmarks=1
          let NERDTreeQuitOnOpen=0
    " }
    " NERDCommenter {
          " Command-/ to toggle comments
          noremap <D-/> <plug>NERDCommenterToggle
          inoremap <D-/> <Esc><plug>NERDCommenterToggle i
    " }
    " TagList support {
          let Tlist_Use_Right_Window = 1
          nnoremap <F4> :TListToggle<CR>
    " }
    " Ctrl-P {
        nnoremap <leader>fb :call NERDSafe("CtrlPBuffer")<CR>
        nnoremap <leader>ff :call NERDSafe("CtrlP")<CR>
        nnoremap <leader>fr :call NERDSafe("CtrlPMRU")<CR>
    " }

    let g:Powerline_symbols = 'fancy'
    " }

" Language-specific settings {
    if has("autocmd")
    " Coffee Script {
          au BufNewFile,BufReadPost *.coffee setl foldmethod=indent nofoldenable
          au BufNewFile,BufReadPost *.coffee setl shiftwidth=2 expandtab
    " }
    " Python {
          autocmd FileType python setlocal sts=4 ts=4 sw=4 tw=79
          autocmd FileType python setlocal foldmethod=indent
          autocmd FileType python set foldlevel=99
    " }
    endif

" }

" Useful Janus functions {
    " Project Tree
    if exists("loaded_nerd_tree")
        autocmd VimEnter * call s:CdIfDirectory(expand("<amatch>"))
        autocmd FocusGained * call s:UpdateNERDTree()
        autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()
    endif

    " Close all open buffers on entering a window if the only
    " buffer that's left is the NERDTree buffer
    function! s:CloseIfOnlyNerdTreeLeft()
        if exists("t:NERDTreeBufName")
          if bufwinnr(t:NERDTreeBufName) != -1
            if winnr("$") == 1
                q
            endif
          endif
        endif
    endfunction

    " If the parameter is a directory, cd into it
    function! s:CdIfDirectory(directory)
        let explicitDirectory = isdirectory(a:directory)
        let directory = explicitDirectory || empty(a:directory)

        if explicitDirectory
            exe "cd " . fnameescape(a:directory)
        endif

        " Allows reading from stdin
        " ex: git diff | mvim -R -
        if strlen(a:directory) == 0
            return
        endif

        if directory
            NERDTree
            wincmd p
            bd
        endif

        if explicitDirectory
            wincmd p
        endif
    endfunction

    " NERDTree utility function
    function! s:UpdateNERDTree(...)
        let stay = 0

        if(exists("a:1"))
            let stay = a:1
        end

        if exists("t:NERDTreeBufName")
            let nr = bufwinnr(t:NERDTreeBufName)
            if nr != -1
                exe nr . "wincmd w"
                exe substitute(mapcheck("R"), "<CR>", "", "")
                if !stay
                    wincmd p
                end
            endif
        endif

        if exists(":CommandTFlush") == 2
            CommandTFlush
        endif
    endfunction

" }

" Abbreviations {
    iabbrev ot to
    iabbrev teh the
" }

" vim: set foldmarker={,} foldlevel=0 foldmethod=marker spell sts=4 ts=4 sw=4:
